// File: uart_tx.v
// Chức năng: Truyền 1 byte dữ liệu qua giao thức UART 8-N-1.
module uart_tx #(
    parameter CLKS_PER_BIT = 5208 // Ví dụ: 50MHz clock / 9600 Baud
) (
    input  wire        clk,
    input  wire        reset,
    input  wire        tx_start,
    input  wire [7:0]  data_in,
    output reg         tx_serial,
    output reg         tx_busy
);

    localparam STATE_IDLE      = 3'b000;
    localparam STATE_START_BIT = 3'b001;
    localparam STATE_DATA_BITS = 3'b010;
    localparam STATE_STOP_BIT  = 3'b011;

    reg [2:0]  state = STATE_IDLE;
    reg [15:0] clk_counter = 0;
    reg [2:0]  bit_index = 0;
    reg [7:0]  data_reg;

    always @(posedge clk) begin
        if (reset) begin
            state <= STATE_IDLE;
            tx_busy <= 0;
            tx_serial <= 1; // Idle line is high
        end else begin
            case (state)
                STATE_IDLE: begin
                    tx_serial <= 1;
                    tx_busy <= 0;
                    clk_counter <= 0;
                    bit_index <= 0;
                    if (tx_start) begin
                        data_reg <= data_in;
                        tx_busy <= 1;
                        state <= STATE_START_BIT;
                    end
                end
                STATE_START_BIT: begin
                    tx_serial <= 0; // Start bit is low
                    if (clk_counter < CLKS_PER_BIT - 1) begin
                        clk_counter <= clk_counter + 1;
                    end else begin
                        clk_counter <= 0;
                        state <= STATE_DATA_BITS;
                    end
                end
                STATE_DATA_BITS: begin
                    tx_serial <= data_reg[bit_index];
                    if (clk_counter < CLKS_PER_BIT - 1) begin
                        clk_counter <= clk_counter + 1;
                    end else begin
                        clk_counter <= 0;
                        if (bit_index < 7) begin
                            bit_index <= bit_index + 1;
                        end else begin
                            state <= STATE_STOP_BIT;
                        end
                    end
                end
                STATE_STOP_BIT: begin
                    tx_serial <= 1; // Stop bit is high
                    if (clk_counter < CLKS_PER_BIT - 1) begin
                        clk_counter <= clk_counter + 1;
                    end else begin
                        clk_counter <= 0;
                        state <= STATE_IDLE; // Done
                    end
                end
                default:
                    state <= STATE_IDLE;
            endcase
        end
    end
endmodule