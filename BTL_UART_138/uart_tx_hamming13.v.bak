// uart_tx_hamming13.v
// UART transmitter with Hamming (13,8) encoding
// Sends: 1 start bit (0), 13 encoded bits (LSB-first), 1 stop bit (1)

module uart_tx_hamming13 #(
    parameter CLKS_PER_BIT = 8
)(
    input        clk,
    input        rst_n,
    input  [7:0] data_in,      // raw data byte
    input        tx_start,     // pulse to start transmission
    output reg   tx_serial,    // UART TX line
    output reg   tx_done       // goes high when transmission completes
);

    // --- Internal states
    localparam IDLE       = 3'd0;
    localparam START_BIT  = 3'd1;
    localparam DATA_BITS  = 3'd2;
    localparam STOP_BIT   = 3'd3;
    localparam CLEANUP    = 3'd4;

    reg [2:0] state;
    reg [3:0] bit_index;
    reg [15:0] clk_count;
    reg [12:0] codeword; // encoded 13-bit frame

    // --- instantiate encoder
    wire [12:0] encoded_bits;
    hamming13_encoder encoder_inst (
        .data_in(data_in),
        .code_out(encoded_bits)
    );

    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            state <= IDLE;
            tx_serial <= 1'b1;
            tx_done <= 1'b0;
            clk_count <= 0;
            bit_index <= 0;
            codeword <= 13'd0;
        end else begin
            case (state)
                IDLE: begin
                    tx_serial <= 1'b1;
                    tx_done <= 1'b0;
                    if (tx_start) begin
                        codeword <= encoded_bits;
                        state <= START_BIT;
                    end
                end

                START_BIT: begin
                    tx_serial <= 1'b0; // start bit
                    if (clk_count < CLKS_PER_BIT - 1)
                        clk_count <= clk_count + 1;
                    else begin
                        clk_count <= 0;
                        state <= DATA_BITS;
                        bit_index <= 0;
                    end
                end

                DATA_BITS: begin
                    tx_serial <= codeword[bit_index]; // send LSB-first
                    if (clk_count < CLKS_PER_BIT - 1)
                        clk_count <= clk_count + 1;
                    else begin
                        clk_count <= 0;
                        if (bit_index < 12)
                            bit_index <= bit_index + 1;
                        else begin
                            bit_index <= 0;
                            state <= STOP_BIT;
                        end
                    end
                end

                STOP_BIT: begin
                    tx_serial <= 1'b1;
                    if (clk_count < CLKS_PER_BIT - 1)
                        clk_count <= clk_count + 1;
                    else begin
                        clk_count <= 0;
                        state <= CLEANUP;
                        tx_done <= 1'b1;
                    end
                end

                CLEANUP: begin
                    state <= IDLE;
                    tx_done <= 1'b0;
                end
            endcase
        end
    end

endmodule
